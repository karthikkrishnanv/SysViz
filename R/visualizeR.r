# R code to visualize cluster system data from R
# Few R packages are expected to have been installed (ggplot2 mainly)
# options.r contains run specific global variables for R (generated by callee script)

source("options.r")
source("multiplot.r")
source("plot.r")
library(ggplot2)
library(plyr)
#library(lattice)
#library(doSNOW)
#library(foreach)
#library(car)

# All the global variables, lists are below
nnodes           <- length(node.name)
ndisks           <- length(disk.dev)
cpu.files       <- list()
cswch.files     <- list()
disktotal.files <- list()
disk.files       <- list()
eth.files       <- list()
memory.files     <- list()
swap.files       <- list()
intr.files       <- list()

cpu.data         <- list()
cswch.data       <- list()
disktotal.data   <- list()
disk.data       <- list()
eth.data         <- list()
memory.data     <- list()
swap.data       <- list()
intr.data       <- list()
#max.decimals    <- 2

GetRandomColorArray <- function(n) {
  col<-rgb(runif(n),runif(n),runif(n),1/4)
  return (col)
}

# sar data is stored as a list
# cpu.data[[1]] = data from host0 etc
# DataOverlapStart/DataOverlapEnd used to align Time window on all hosts

DataOverlapStart <- function(cpu.data) {
  window.start <- (as.vector(cpu.data[[1]]$Time))[1]
  for(i in 2:nnodes) {
    if (nnodes >= 2)
      window.start <- max(window.start,(as.vector(cpu.data[[i]]$Time))[1])
  }
  return (window.start)
}

DataOverlapEnd <- function(cpu.data) {
  window.end <- (as.vector(cpu.data[[1]]$Time))[nrow(cpu.data[[1]])]
  for(i in 2:nnodes) {
    if (nnodes >= 2)
      window.end <- min(window.end, (as.vector(cpu.data[[i]]$Time))[nrow(cpu.data[[i]])])
  }
  return (window.end)

}

# To apply any specific time window filter
# If none given (filter.choice == FALSE), auto extract most overlapping window

ApplyTimeWindowFilter <- function(d) {
  if (filter.choice == TRUE) {
    i0 <- which(strptime(d$Time,'%H:%M:%S') > strptime(filter.start,'%H:%M:%S'))
    i1 <- which(strptime(d$Time,'%H:%M:%S') < strptime(filter.end,'%H:%M:%S'))
    filtered <- d[min(i0):max(i1),]
    return (filtered)
  }
  else {
    start.window <- DataOverlapStart(cpu.data)
    end.window <- DataOverlapEnd(cpu.data)
    i0 <- which(strptime(d$Time,'%H:%M:%S') > strptime(start.window,'%H:%M:%S'))
    i1 <- which(strptime(d$Time,'%H:%M:%S') < strptime(end.window,'%H:%M:%S'))
    if (min(i0) < max(i1))
      filtered <- d[min(i0):max(i1),]
    else
      filtered <- d[,]
    return (filtered)
  }
}


# main function to fill all the global data
FillGlobalData <- function() {
  for(i in 1:nnodes) {
    cpu.files[[i]]         <<- paste(log.dir,node.name[i],"/cpu.csv",sep="/")
    cswch.files[[i]]       <<- paste(log.dir,node.name[i],"/cswch.csv",sep="/")
    disktotal.files[[i]]  <<- paste(log.dir,node.name[i],"/disk_total.csv",sep="/")
    disk.files[[i]]       <<- paste(log.dir,node.name[i],"/disk.csv",sep="/")
    eth.files[[i]]         <<- paste(log.dir,node.name[i],"/eth.csv",sep="/")
    memory.files[[i]]     <<- paste(log.dir,node.name[i],"/memory.csv",sep="/")
    swap.files[[i]]       <<- paste(log.dir,node.name[i],"/swap.csv",sep="/")
    intr.files[[i]]       <<- paste(log.dir,node.name[i],"/INTR.csv",sep="/")

    cpu.data[[i]]         <<- read.csv(cpu.files[[i]],header <<- TRUE)
    cswch.data[[i]]       <<- read.csv(cswch.files[[i]],header <<- TRUE)
    disktotal.data[[i]]   <<- read.csv(disktotal.files[[i]],header <<- TRUE)
    disk.data[[i]]         <<- read.csv(disk.files[[i]],header <<- TRUE)
    eth.data[[i]]         <<- read.csv(eth.files[[i]],header <<- TRUE)
    memory.data[[i]]       <<- read.csv(memory.files[[i]],header <<- TRUE)
    swap.data[[i]]         <<- read.csv(swap.files[[i]],header <<- TRUE)
    intr.data[[i]]         <<- read.csv(intr.files[[i]],header <<- TRUE)

    cpu.data[[i]]$"node"   <<- node.name[[i]]
    cswch.data[[i]]$"node"<<- node.name[[i]]
    disktotal.data[[i]]$"node"  <<- node.name[[i]]
    disk.data[[i]]$"node" <<- node.name[[i]]
    eth.data[[i]]$"node"  <<- node.name[[i]]
    memory.data[[i]]$"node"<<- node.name[[i]]
    swap.data[[i]]$"node" <<- node.name[[i]]
    intr.data[[i]]$"node" <<- node.name[[i]]
  }

# Bracket data to find most overlapped time window across nodes 
  for(i in 1:nnodes) { 
    cpu.data[[i]]       <<- ApplyTimeWindowFilter(cpu.data[[i]])
    cswch.data[[i]]     <<- ApplyTimeWindowFilter(cswch.data[[i]])
    disktotal.data[[i]] <<- ApplyTimeWindowFilter(disktotal.data[[i]])
    disk.data[[i]]       <<- ApplyTimeWindowFilter(disk.data[[i]])
    eth.data[[i]]       <<- ApplyTimeWindowFilter(eth.data[[i]])
    memory.data[[i]]     <<- ApplyTimeWindowFilter(memory.data[[i]])
    swap.data[[i]]       <<- ApplyTimeWindowFilter(swap.data[[i]])
    intr.data[[i]]       <<- ApplyTimeWindowFilter(intr.data[[i]])
  }  

}

# Parse all network data to find most active eth name
PickMostActiveEth <- function(eth.data) {
  eth.list <- list()
  eths.all <- as.vector(unique(eth.data$IFACE))
  index <- 1
  for(i in 1:length(eths.all)) {
    if (eths.all[i] != "lo") {
      eth.list[[index]] <- eths.all[i]
      index <- index+1
    }
  }
  eth.mean <- list()
  index <- 1
  for(i in 1:length(eth.list)) {
    eth.mean[index] <- mean(subset(eth.data,IFACE==eth.list[[i]])$rxkB.s)
    index <- index+1
  }
  max_mean <- max(as.numeric(eth.mean))
  max_index <- which(eth.mean==max_mean)
  return (eth.list[max_index])
    
}

PlotData <- function(datalist,col.x,col.y,mul,tag,xlabel="Time",ylabel=col.y) {
  
  datalist.merged <- datalist[[1]]
  for(i in 2:nnodes) {
    if (nnodes >= 2)
      datalist.merged <- rbind(datalist.merged,datalist[[i]])
  }
  datalist.merged[col.y] <- mul*datalist.merged[col.y]
  datalist.merged["tempval"] <- datalist.merged[col.y]
  datalist.merged[,col.x] <- as.numeric(strptime(datalist.merged[,col.x],'%H:%M:%S'))
  total <- length(subset(datalist.merged,node==node.name[1])$Time)
  nchunk <- 30
  if (total > nchunk) {
    markers <-seq(1,total,as.integer(total/nchunk))
    breaks <- sort(((subset(datalist.merged,node==node.name[1])$Time)[markers]))
    labels <- format(as.POSIXlt(breaks,origin="1970-01-01"),'%H:%M:%S')
  }else {
    breaks <- subset(datalist.merged,node==node.name[1])$Time
    labels <- format(as.POSIXlt(breaks,origin="1970-01-01"),'%H:%M:%S')
  }

  title = paste("Data Nodes",tag," ",sep="")
  p1 <- ggplot(data=datalist.merged,aes_string(x=col.x,y=col.y,
               color="node",group="node"))
  p1 <- p1 + geom_point(size=2) +
             xlab(xlabel) + ylab (ylabel) + ggtitle(title) +
             scale_x_continuous(breaks=breaks,labels=labels) 
  p1 <- p1 + theme(axis.text.x  = element_text(angle=90, vjust=0.5, size=16,face="bold"))
  p1 <- p1 + theme(axis.title.x  = element_text(size=24,face="bold"))
  p1 <- p1 + theme(axis.title.y  = element_text(size=24,face="bold"))
  p1 <- p1 + theme(plot.title  = element_text(size=24,face="bold"))
  p1 <- p1 + theme(axis.text.x  = element_text(size=16,face="bold"))
  p1 <- p1 + theme(axis.text.y  = element_text(size=16,face="bold"))
  p1 <- p1 + theme(legend.text  = element_text(size=20))

  datalist.merged.ecdf <- ddply(datalist.merged, .(node), 
                                transform, ecdf=ecdf(tempval)(tempval) )

  p2 <- ggplot( datalist.merged.ecdf, aes(tempval, ecdf, colour = node) ) 
  p2 <- p2 + geom_line(aes(group = node,colour = node)) +
             xlab(ylabel) + ylab("ecdf") +
             ggtitle (paste("Cumulative Distribution of",tag,sep=""))
  p2 <- p2 + theme(axis.title.x  = element_text(size=24,face="bold"))
  p2 <- p2 + theme(axis.title.y  = element_text(size=24,face="bold"))
  p2 <- p2 + theme(plot.title  = element_text(size=24,face="bold"))
  p2 <- p2 + theme(axis.text.x  = element_text(size=16,face="bold"))
  p2 <- p2 + theme(axis.text.y  = element_text(size=16,face="bold"))
  p2 <- p2 + theme(legend.text  = element_text(size=20))


  breaks = GetOptimalBreaks(datalist.merged,"tempval","node")
  node.matrix = GetClusterBarplotData(datalist.merged,"tempval","node")
  title = paste("Clustered Barplot of",tag,sep="")
  if (is.null(node.matrix) == FALSE) {
    p3 = ggplot(data=node.matrix,aes(x=factor(bin.val),y=value,fill=node)) 
    p3 <- p3 + geom_bar(stat="identity",position=position_dodge())
    p3 <- p3 + ggtitle (paste("Barplot clusters of",tag,sep=""))
    p3 <- p3 + xlab(ylabel) + ylab("% of Runtime")
    p3 <- p3 + theme(axis.title.x  = element_text(size=24,face="bold"))
    p3 <- p3 + theme(axis.title.y  = element_text(size=24,face="bold"))
    p3 <- p3 + theme(plot.title  = element_text(size=24,face="bold"))
    p3 <- p3 + theme(axis.text.x  = element_text(size=16,face="bold"))
    p3 <- p3 + theme(axis.text.y  = element_text(size=16,face="bold"))
    p3 <- p3 + theme(legend.text  = element_text(size=20))
    multiplot(p1,p2,p3,cols=1)
  } else {
    multiplot(p1,p2,cols=1)
  }

}


PlotCPU <- function() {
  mul=1
  PlotData(cpu.data,"Time","X.usr",mul," %usr","Time","%usr")
  PlotData(cpu.data,"Time","X.sys",mul," %sys","Time","%sys")
}

PlotDiskSum <- function() {
  mul=512/(1024*1024)
  PlotData(disktotal.data,"Time","bread.s",mul,
           " TotalDisk Read (MB/s)",ylabel="read MB/s")
  PlotData(disktotal.data,"Time","bwrtn.s",mul,
           " TotalDisk Written (MB/s)",ylabel="write MB/s")
  mul=1
  PlotData(disktotal.data,"Time","rtps",mul," TotalDisk Read req/s",ylabel="rtps")
  PlotData(disktotal.data,"Time","wtps",mul," TotalDisk Write req/s",ylabel="wtps")
}


PlotDiskIndividual <- function() {
  for(d in 1:ndisks)
  {
    diskdata.sub=list()
    for(i in 1:nnodes)
    {
      diskdata.sub[[i]] <- subset(disk.data[[i]],DEV==disk.dev[d])
    }
    mul=1
    PlotData(diskdata.sub,"Time","await",mul,
             paste(" ",disk.dev[d]," await (ms)"),ylabel="await")
    mul = 512/1024
    PlotData(diskdata.sub,"Time","avgrq.sz",mul,
             paste(" ",disk.dev[d]," Avg Req Size (KBs)"),ylabel="avgrq(KBs)")
    mul=1
    PlotData(diskdata.sub,"Time","avgqu.sz",mul,
             paste(" ",disk.dev[d]," Avg Queue len"),ylabel="avgqu.sz")
    mul=512/(1024*1024)
    PlotData(diskdata.sub,"Time","rd_sec.s",mul,
             paste(" ",disk.dev[d]," Read(MB/s)"),ylabel="Read (MB/s)")
    PlotData(diskdata.sub,"Time","wr_sec.s",mul,
             paste(" ",disk.dev[d]," Write(MB/s)"),ylabel="Write (MB/s)")
    mul=1
    PlotData(diskdata.sub,"Time","svctm",mul,
             paste(" ",disk.dev[d]," svctm(ms)"),ylabel="svctm(ms)")
  }
}


PlotNetwork <- function(){
  ethdata.sub=list()
  for(i in 1:nnodes){
    ethdata.sub[[i]] <- subset(eth.data[[i]],IFACE=="lo")
  }
  mul=1000*8/(1000*1000*1000)
  PlotData(ethdata.sub,"Time","rxkB.s",mul," lo receive (Gb/s)",ylabel="recv (Gb/s)")
  PlotData(ethdata.sub,"Time","txkB.s",mul," lo transmit (Gb/s)",ylabel="send (Gb/s)")

  ethdata.sub=list()
  for(i in 1:nnodes) {
    iface_filter <- PickMostActiveEth(eth.data[[i]])
    ethdata.sub[[i]] <- subset(eth.data[[i]],IFACE==iface_filter)
  }  
  mul=1000*8/(1000*1000*1000)
  PlotData(ethdata.sub,"Time","rxkB.s",mul," eth receive (Gb/s)",ylabel="recv (Gb/s)")
  PlotData(ethdata.sub,"Time","txkB.s",mul," eth transmit (Gb/s)",ylabel="send (Gb/s)")
}


PlotMemory <- function(){
  mul=1
  PlotData(memory.data,"Time","X.memused",mul," %memused",ylabel="%memused")
  mul=1024/(1024*1024*1024)
  PlotData(memory.data,"Time","kbcached",mul," kernel cache data (GBs)",ylabel="GBcached")
  mul=1024/(1024*1024*1024)
  PlotData(memory.data,"Time","kbcommit",mul," commit data (GBs)",ylabel="GB commit")
  mul=1024/(1024*1024)
  PlotData(swap.data,"Time","kbswpused",mul," swapused(MBs)",ylabel="swap used (MBs)")
}

PlotMisc <- function(){
  mul=1
  PlotData(cswch.data,"Time","proc.s",mul," proc/s","Time","proc/s")
  PlotData(cswch.data,"Time","cswch.s",mul," cswch/s","Time","cswch/s")
  mul=1
  PlotData(intr.data,"Time","intr.s",mul," intr/s",ylabel="intr/s")
}

unlink(sar.pdf)
pdf(sar.pdf,height=15,width=15)
FillGlobalData()
PlotCPU()
PlotDiskSum()
PlotDiskIndividual()
PlotNetwork()
PlotMemory()
PlotMisc()
dev.off()

